From cb2e2c26dc841bb4cab2d3b2ff376936f6c39e68 Mon Sep 17 00:00:00 2001
From: Mark Vitale <mvitale@sinenomine.net>
Date: Thu, 4 Aug 2016 18:18:15 -0400
Subject: LINUX: split dentry eviction from osi_TryEvictVCache

To make osi_TryEvictVCache clearer, and to prepare for a future change
in dentry eviction, split the dentry eviction logic into its own routine
osi_TryEvictDentries.

No functional difference should be incurred by this commit.

Reviewed-on: https://gerrit.openafs.org/12362
Reviewed-by: Benjamin Kaduk <kaduk@mit.edu>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Joe Gorse <jhgorse@gmail.com>
(cherry picked from commit 742643e306929ac979ab69515a33ee2a3f2fa3fa)

Change-Id: I750fc7606ca56e784a60bdbc13a32d21fe307429
---
 src/afs/LINUX/osi_vcache.c | 103 +++++++++++++++++++++++++--------------------
 1 file changed, 57 insertions(+), 46 deletions(-)

diff --git a/src/afs/LINUX/osi_vcache.c b/src/afs/LINUX/osi_vcache.c
index 8a0c57899..3682bdc29 100644
--- a/src/afs/LINUX/osi_vcache.c
+++ b/src/afs/LINUX/osi_vcache.c
@@ -15,77 +15,88 @@
 
 #include "osi_compat.h"
 
-int
-osi_TryEvictVCache(struct vcache *avc, int *slept, int defersleep) {
-    int code;
-
+void
+osi_TryEvictDentries(struct vcache *avc)
+{
     struct dentry *dentry;
     struct inode *inode = AFSTOV(avc);
 #if defined(D_ALIAS_IS_HLIST) && !defined(HLIST_ITERATOR_NO_NODE)
     struct hlist_node *p;
 #endif
 
-    /* First, see if we can evict the inode from the dcache */
-    if (defersleep && avc != afs_globalVp && VREFCOUNT(avc) > 1 && avc->opens == 0) {
-	*slept = 1;
-	AFS_FAST_HOLD(avc);
-	ReleaseWriteLock(&afs_xvcache);
-        AFS_GUNLOCK();
-
 #if defined(HAVE_DCACHE_LOCK)
-        spin_lock(&dcache_lock);
+    spin_lock(&dcache_lock);
 
 restart:
-	list_for_each_entry(dentry, &inode->i_dentry, d_alias) {
-	    if (d_unhashed(dentry))
-		continue;
-	    dget_locked(dentry);
-
-	    spin_unlock(&dcache_lock);
-	    if (d_invalidate(dentry) == -EBUSY) {
-		dput(dentry);
-		/* perhaps lock and try to continue? (use cur as head?) */
-		goto inuse;
-	    }
+    list_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+	if (d_unhashed(dentry))
+	    continue;
+	dget_locked(dentry);
+
+	spin_unlock(&dcache_lock);
+	if (d_invalidate(dentry) == -EBUSY) {
 	    dput(dentry);
-	    spin_lock(&dcache_lock);
-	    goto restart;
+	    /* perhaps lock and try to continue? (use cur as head?) */
+	    goto inuse;
 	}
-	spin_unlock(&dcache_lock);
+	dput(dentry);
+	spin_lock(&dcache_lock);
+	goto restart;
+    }
+    spin_unlock(&dcache_lock);
 #else /* HAVE_DCACHE_LOCK */
-	spin_lock(&inode->i_lock);
+    spin_lock(&inode->i_lock);
 
 restart:
 #if defined(D_ALIAS_IS_HLIST)
 # if defined(HLIST_ITERATOR_NO_NODE)
-	hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+    hlist_for_each_entry(dentry, &inode->i_dentry, d_alias) {
 # else
-	hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
+    hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) {
 # endif
 #else
-	list_for_each_entry(dentry, &inode->i_dentry, d_alias) {
+    list_for_each_entry(dentry, &inode->i_dentry, d_alias) {
 #endif
-	    spin_lock(&dentry->d_lock);
-	    if (d_unhashed(dentry)) {
-		spin_unlock(&dentry->d_lock);
-		continue;
-	    }
+	spin_lock(&dentry->d_lock);
+	if (d_unhashed(dentry)) {
 	    spin_unlock(&dentry->d_lock);
-	    dget(dentry);
-
-	    spin_unlock(&inode->i_lock);
-	    if (afs_d_invalidate(dentry) == -EBUSY) {
-		dput(dentry);
-		/* perhaps lock and try to continue? (use cur as head?) */
-		goto inuse;
-	    }
-	    dput(dentry);
-	    spin_lock(&inode->i_lock);
-	    goto restart;
+	    continue;
 	}
+	spin_unlock(&dentry->d_lock);
+	dget(dentry);
+
 	spin_unlock(&inode->i_lock);
+	if (afs_d_invalidate(dentry) == -EBUSY) {
+	    dput(dentry);
+	    /* perhaps lock and try to continue? (use cur as head?) */
+	    goto inuse;
+	}
+	dput(dentry);
+	spin_lock(&inode->i_lock);
+	goto restart;
+    }
+    spin_unlock(&inode->i_lock);
 #endif /* HAVE_DCACHE_LOCK */
 inuse:
+    return;
+}
+
+
+int
+osi_TryEvictVCache(struct vcache *avc, int *slept, int defersleep)
+{
+    int code;
+
+    /* First, see if we can evict the inode from the dcache */
+    if (defersleep && avc != afs_globalVp && VREFCOUNT(avc) > 1
+	&& avc->opens == 0) {
+	*slept = 1;
+	AFS_FAST_HOLD(avc);
+	ReleaseWriteLock(&afs_xvcache);
+	AFS_GUNLOCK();
+
+	osi_TryEvictDentries(avc);
+
 	AFS_GLOCK();
 	ObtainWriteLock(&afs_xvcache, 733);
 	AFS_FAST_RELE(avc);
-- 
2.11.0

